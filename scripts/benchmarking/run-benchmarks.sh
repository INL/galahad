#!/bin/bash
# Run benchmarks and store the result in the galahad-server
# This script is intended to be a progressive load test of the server
# Things might go wrong and/or your server may run out of capacity.
# So make sure you know what you are doing!
# It is recommended to run this script once only, after deployment and before allowing users access to the server

case $PWD/ in
  */scripts/benchmarking/) echo "I will run in scripts/benchmarking";;
  *) echo "I refuse to run outside of scripts/benchmarking" && exit 1;;
esac

API_URL="http://localhost:8010"
SERVER_CONTAINER="galahad_server_1" # can also be "galahad-server-1"
SOURCE_LAYER="sourceLayer"
FORMATS=("naf" "tei-p5" "tsv") # "folia"
TAGGERS=("dev-naive") # "frog-nld" "pie-mixed")
start=`date +%s`

# exit when any command fails
set -e

ENV=''
if [ "$1" = "prod" ]
then
    ENV='prod'
    if [ -n "$2" ]
    then
        SERVER_CONTAINER="$2"
    fi
elif [ "$1" = "dev" ]
then
    ENV='dev'
else
    echo "Usage $0 prod|dev [galahad_server_container_name]"
    exit 1
fi

# keep track of the last executed command
trap 'last_command=$current_command; current_command=$BASH_COMMAND' DEBUG
# echo an error message before exiting
trap 'exit_code=$?; final_command=$last_command;
if [ $exit_code -ne 0 ]; then 
    echo "\"${final_command}\" or a subsequent command failed with exit code $exit_code. If this is an eror, please fix it and rerun the benchmarks." 
    shareFailure
fi' EXIT

echo ""
echo "--------------------------------------------------------------------------"
echo "$(date) $(realpath $0)"
echo ""
echo "Run benchmarks and store the result in the galahad-server"
echo "This script will upload, tag, evaluate and export increasingly larger corpora."
echo "This may take very long, and use a lot of resources. You are encouraged to interrupt the process at any time if it takes to long"
echo "The state at time of interruption is consider the result or score of the benchmark."

while true; do
    read -p "Do you know what you are doing? " yn
    case $yn in
        [Yy]* ) break;;
        [Nn]* ) echo "You could start by reading $0 or visit https://github.com/INL/Galahad"; exit;;
        * ) echo "Please answer yes or no.";;
    esac
done
while true; do
    read -p "Are you sure you want to run this PROGRESSIVE LOAD TEST? " yn
    case $yn in
        [Yy]* ) break;;
        [Nn]* ) echo "Ok then, you can run this script at a later point."; exit;;
        * ) echo "Please answer yes or no.";;
    esac
done

echo "Very well, the benchmarking will now begin"
echo ""
 
rm -f benchmarks.yml

INDENT=0

indent_more () {
    INDENT=$(($INDENT+1))
}

indent_less () {
    INDENT=$(($INDENT-1))
}

output () {
    if [ "$INDENT" -gt "0" ]
    then
        for i in $(seq 1 $INDENT); do echo "  "; done
        for i in $(seq 1 $INDENT); do printf "  " >> benchmarks.yml; done
    fi
    echo $1
    printf "$1\n" >> benchmarks.yml
}

beginReport () {
    output "# generated by benchmarking/run-benchmarks.sh"
    output "# results may vary base on the setup used at runtime"
    nodename=`uname --nodename`
    head=`echo $nodename | head -c 2`
    tail=`echo $nodename | tail -c 3`
    safename="$head..$tail"
    output "benchmark-server: $safename"
    output "api_url: $API_URL"
}

shareFailure () {
    timestamp=`date +%s%N`
    output "FAILURE: $timestamp"
    shareReport
}

shareReport () {
    if [ "$ENV" = "prod" ]
    then
        docker cp benchmarks.yml $SERVER_CONTAINER:benchmarks.yml
    elif [ "$ENV" = "dev" ]
    then
        cp benchmarks.yml ../../server/benchmarks.yml
    fi
}

begin_benchmark () {
    benchmark_start=`date +%s%N`
    BENCHMARK_NAME=$1
    output "$1:"
    indent_more
    output "start: $benchmark_start"
    shareReport
}

begin_step () {
    step_start=`date +%s%N`
    output "$1:"
    indent_more
    output "start: $step_start"
    shareReport
}

begin_tagger () {
    tagger_start=`date +%s%N`
    output "$1:"
    indent_more
    output "start: $tagger_start"
    shareReport
}

begin_evaluation_step () {
    step_start=`date +%s%N`
    output "$1:"
    indent_more
    output "start: $step_start"
    shareReport
}

end_evaluation_step () {
    step_end=`date +%s%N`
    output "end: $step_end"
    indent_less
    shareReport
}

end_tagger () {
    tagger_end=`date +%s%N`
    duration=$(($tagger_end-$tagger_start))
    output "end: $tagger_end"
    output "duration: $duration"
    indent_less
    shareReport
}

end_step () {
    step_end=`date +%s%N`
    duration=$(($step_end-$step_start))
    output "end: $step_end"
    output "duration: $duration"
    indent_less
    shareReport
}

end_benchmark () {
    benchmark_end=`date +%s%N`
    duration=$(($benchmark_end-$benchmark_start))
    output "end: $benchmark_end"
    output "duration: $duration"
    indent_less
    shareReport
}

do_benchmark () {
    begin_benchmark $1
    begin_step "data"

    echo "--- creating a corpus --- "
    eval CORPUS_UUID=$(curl -X POST --header 'Content-Type: application/json' \
        --header 'Accept: application/json' \
        -d "{ \"name\": \"$BENCHMARK_NAME\", \"eraFrom\": 0, \"eraTo\": 0, \"collaborators\": [ \"Mark Bench\" ], \"sourceName\": \"source name\",  \"sourceURL\": \"http://string\" }" \
        "$API_URL/corpora")
    echo "Corpus uuid is <$CORPUS_UUID>"
    echo ""
    output "corpus UUID: '$CORPUS_UUID'"

    for FILE in $BENCHMARK_NAME/*
    do
        echo " --- uploading file --- "
        curl_result=$(curl -F "file=@$FILE" --write-out 'HTTP status: %{http_code}' "$API_URL/corpora/$CORPUS_UUID/documents")
        if [[ $? -ne 0 ]] || [[ ${curl_result}  != *'HTTP status: 200' ]]; then
            echo "Uploading failed. The output of curl was $curl_result. You will fail this test."
            # premature_fail
            exit 1
        fi
        echo $curl_result
        echo " --- uploading finished --- "
        echo ""

    done # for FILE in $BENCHMARK_NAME/*

    end_step "data"
    begin_step "annotate"

    for TAGGER in "${TAGGERS[@]}"; do
    begin_tagger $TAGGER

    echo " --- tagging started ---"
    echo  "using url: $API_URL/corpora/$CORPUS_UUID/jobs/$TAGGER"
    curl_result=$(curl -X POST "$API_URL/corpora/$CORPUS_UUID/jobs/$TAGGER" -H  "accept: */*" -d "")
    if [[ $? -ne 0 ]] ; then
        echo "Failed to start job $TAGGER. The output of curl was $curl_result. You will fail this test."
        # premature_fail
        exit 1
    fi
    echo $curl_result
    echo ""

    polling_max=10000000000
    polling=0
    timed_out=true # true unless otherwise
    while (($polling < $polling_max)); do
        sleep 1
        echo "[$BENCHMARK_NAME] polling tagger $polling"
        isBusy=$(curl -X GET --silent --header 'Accept: application/json' "$API_URL/corpora/$CORPUS_UUID/jobs/$TAGGER/isBusy")
        if [[ $? -ne 0 ]]; then
            echo "polling $TAGGER failed. The output of curl was $isBusy. You will fail this test."
            # premature_fail
            exit 1
        fi
        echo "[$BENCHMARK_NAME] isBusy: $isBusy"
        polling=$((polling+1))
        if [[ $isBusy == false ]]; then
            echo " --- tagging finished. --- "
            # We can speed ahead
            polling=$polling_max
            timed_out=false
        fi
    done # While polling < polling_max
    if [[ $timed_out == true ]]; then
        echo "tagger $TAGGER timed out. You will fail this test." # TODO consider we even want a timeout for this test
        # premature_fail
        exit 1
    fi

    jobSummary=$(curl -X GET --header 'Accept: application/json' "$API_URL/corpora/$CORPUS_UUID/jobs/$TAGGER")
    # output "job_summary: '$jobSummary'"

    hasError=$(curl -X GET --silent --header 'Accept: application/json' "$API_URL/corpora/$CORPUS_UUID/jobs/$TAGGER/hasError")
    if [[ $hasError == true ]]; then
            echo " --- tagging finished, but has errors, benchmark will end here --- "
            output "ERROR: taggers has errors, please inspect"
            output "link: /galahad/annotate/annotations?corpus=$CORPUS_UUID"
            exit 1
    fi

    end_tagger $TAGGER
    done # for TAGGER in "${TAGGERS[@]}"

    end_step "annotate"
    begin_step "evaluate"

        for TAGGER in "${TAGGERS[@]}"; do
            begin_tagger $TAGGER
    
            begin_evaluation_step "distribution"
                curl -X GET --header 'Accept: application/json' "$API_URL/corpora/$CORPUS_UUID/jobs/$TAGGER/evaluation/distribution"
            end_evaluation_step "distribution"
            begin_evaluation_step "metrics"
                echo "Note: metrics only make sense if a source layer is present on the documents."
                    output "note: without sourcelayer in the documents, this step is not a good benchmark"
                curl -X GET --header 'Accept: application/json' "$API_URL/corpora/$CORPUS_UUID/jobs/$TAGGER/evaluation/metrics?reference=$SOURCE_LAYER"
            end_evaluation_step "metrics"
            begin_evaluation_step "confusion"
                echo "Note: confusion only make sense if a source layer is present on the documents."
                output "note: without sourcelayer in the documents, this step is not a good benchmark"
                curl -X GET --header 'Accept: application/json' "$API_URL/corpora/$CORPUS_UUID/jobs/$TAGGER/evaluation/confusion?reference=$SOURCE_LAYER"
            end_evaluation_step "confusion"

            end_tagger $TAGGER
        done # for TAGGER in "${TAGGERS[@]}"
    end_step "evaluate"

    begin_step "export"
    echo "Export merge is skipped because it is not a very usefull test for text-only files."
    output "note: Export merge is skipped because it is not a very usefull test for text-only files."
    for FORMAT in "${FORMATS[@]}"; do
        begin_step $FORMAT
        for TAGGER in "${TAGGERS[@]}"; do
            begin_tagger $TAGGER
            
            curl -X GET --header 'Accept: text/plain' -OJ "$API_URL/corpora/$CORPUS_UUID/jobs/$TAGGER/export/convert?format=$FORMAT"
            # We dont care about the corpus, remove it
            rm *.zip

            end_tagger $TAGGER
        done # for TAGGER in "${TAGGERS[@]}"
        end_step $FORMAT
    done # for FORMAT in "${FORMATS[@]}"
    end_step "export"
    end_benchmark

}

beginReport

do_benchmark "1doc_100char"
do_benchmark "1doc_10kchar"

# generate our own data, to keep it out of git
rm -rf 1doc_100kchar # remove to clean up previous failure
mkdir 1doc_100kchar
for i in $(seq 1 10); do cat 1doc_10kchar/10kch.txt >> 1doc_100kchar/100kch.txt; done
do_benchmark "1doc_100kchar"
rm -r 1doc_100kchar

# generate our own data, to keep it out of git
rm -rf 1doc_1mchar # remove to clean up previous failure
mkdir 1doc_1mchar
for i in $(seq 1 100); do cat 1doc_10kchar/10kch.txt >> 1doc_1mchar/1mch.txt; done
do_benchmark "1doc_1mchar"
rm -r 1doc_1mchar

# generate our own data, to keep it out of git
rm -rf 1doc_10mchar # remove to clean up previous failure
mkdir 1doc_10mchar
for i in $(seq 1 1000); do cat 1doc_10kchar/10kch.txt >> 1doc_10mchar/10mch.txt; done
do_benchmark "1doc_10mchar"
rm -r 1doc_10mchar

# generate our own data, to keep it out of git
rm -rf 10doc_10kchar # remove to clean up previous failure
mkdir 10doc_10kchar
for i in $(seq 1 10); do cp 1doc_10kchar/10kch.txt 10doc_10kchar/10kch$i.txt; done
do_benchmark "10doc_10kchar"
rm -r 10doc_10kchar

# generate our own data, to keep it out of git
rm -rf 100doc_10kchar # remove to clean up previous failure
mkdir 100doc_10kchar
for i in $(seq 1 100); do cp 1doc_10kchar/10kch.txt 100doc_10kchar/10kch$i.txt; done
do_benchmark "100doc_10kchar"
rm -r 100doc_10kchar

# generate our own data, to keep it out of git
rm -rf 1kdoc_10kchar # remove to clean up previous failure
mkdir 1kdoc_10kchar
for i in $(seq 1 1000); do cp 1doc_10kchar/10kch.txt 1kdoc_10kchar/10kch$i.txt; done
do_benchmark "1kdoc_10kchar"
rm -r 1kdoc_10kchar

# generate our own data, to keep it out of git
rm -rf 10kdoc_10kchar # remove to clean up previous failure
mkdir 10kdoc_10kchar
for i in $(seq 1 10000); do cp 1doc_10kchar/10kch.txt 10kdoc_10kchar/10kch$i.txt; done
do_benchmark "10kdoc_10kchar"
rm -r 10kdoc_10kchar


cat benchmarks.yml
shareReport

rm benchmarks.yml

echo "$(date) benchmarks finished."
echo "Visit https://github.com/INL/Galahad for more, or view the benchmarks result at app_url/benchmarks"
end=`date +%s`
runtime=$((end-start))
echo "Runtime $runtime seconds"
echo "--------------------------------------------------------------------------"
echo ""
